## Binary translater with peephole superoptimizer

- pdf: https://www.usenix.org/legacy/events/osdi08/tech/full_papers/bansal/bansal.pdf
- slides
    - https://www.slideserve.com/johnna/binary-translation-using-peephole-superoptimizers-powerpoint-ppt-presentation#google_vignette
    - https://theory.stanford.edu/~sbansal/talks/osq.pdf

> We have implemented a prototype binary translator
from PowerPC to x86. Our prototype handles nearly all
of the PowerPC and x86 opcodes and using it we have
successfully translated large executables and libraries.

ダイナミックライブラリに対応しているかは不明。

- harvester
    - > A module called the harvester extracts target instruction sequences from a set of training programs.
        These are the instruction sequences we seek to optimize
    - レジスタマップを入れ替えることで同一とみなせる命令列も別物として扱うっぽい。
- enumerator
    - > A module called the enumerator enumerates all
        possible instruction sequences up to a certain
        length. Each enumerated instruction sequence s is
        checked to see if it is equivalent to any target instruction sequence t.
    - ランダムインプットによる実行テストで多くの選択肢を弾く。次に形式検証(SAT)で厳密にテストする
- peephole translation rules
    - > The learned (target sequence, optimal sequence)
        pairs are organized into a lookup table indexed by
        target instruction sequence
    - (長さ3以下の命令列, Liveレジスタ, ) -> 変換後の命令列 (Table3)
    - e.g. (`mr r1,r2`, `r1,r2`, `r1→eax;r2→M1`) -> `movl M1,eax`

> Once constructed, the optimizer is applied to an executable by simply looking up target sequences in the
executable for a known better replacement. The purpose of using harvested instruction sequences is to focus the search for optimizations on the code sequences
(usually generated by other compilers) that appear in actual programs. Typically, all instruction sequences up
to length 5 or 6 are harvested, and the enumerator tries
all instruction sequences up to length 3 or 4.

長さ5以下の命令を抽出(harvest)して、(enumeratorで)3,4命令以下の命令列を変換候補にする
組み合わせ爆発のため、3命令(length-3)でharvestした

> For 16 PowerPC opcodes our translator failed to find a
short equivalent x86 sequence of instructions automatically. In such cases, we allow manual additions to the
peephole table. Table 6 describes the number and types
of hand additions: 9 are due to instructions involving indirect jumps and 7 are due to complex PowerPC instructions that cannot be emulated using a bounded length straight-line sequence of x86 instructions. For some more complex instructions mostly involving interrupts
and other system-related tasks, we used the slow but simple approach of emulation using C-code.

手動で追加した命令について

| Num of Addition | Reason
| -- | --
| 2 | Overflow/underflow semantics of the divide instruction (div)
| 2 | Overflow semantics of srawi shift instruction
| 1 | The rotate instruction rlwinm
| 1 | The cntlzw instruction
| 1 | The mfcr instruction
| 9 | Indirect jumps referencing the jumptable

jump tableはPLTのことを指している?

4.3

> Like all other opcodes, control flow instructions are
also translated using peephole rules. Direct jumps in
the source are translated to direct jumps in the translated code, with the jump destination being appropriately
adjusted to point to the corresponding translated code.
Our superoptimizer is capable of automatically learning
translations involving direct jump instructions.
To handle conditional jumps, the condition codes of
the source architecture need to be faithfully represented
in the destination architecture. Handling condition codes
correctly is one of the more involved aspects of binary
translation because of the divergent condition-code representations used by different architectures. We discuss
our approach to handling condition codes in the context
of our PowerPC-x86 binary translator; see Section 5.3.
The handling of indirect jumps is more involved and is
done differently for static and dynamic translators. We
discuss this in detail in Section 5.4

`call 0xdeadbeaf (func_foo)` のようなシンボルへのジャンプは対応するアドレスを探すっぽい。
